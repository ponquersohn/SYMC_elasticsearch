
input {
    syslog{
       port => 5140
    }
}

filter {
    
    grok {
        break_on_match => "true"
        patterns_dir => ["./patterns"]
        # single lines
        match => { "message" => "%{SMG_ACCEPT_OBJ_PTRN}"}
        match => { "message" => "%{SMG_TLS_RECEIVED_PTRN}"}
        match => { "message" => "%{SMG_SUBJECT_OBJ_PTRN}"}
        match => { "message" => "%{SMG_SOURCE_OBJ_PTRN}"}
        match => { "message" => "%{SMG_SENDER_OBJ_PTRN}"}
        match => { "message" => "%{SMG_MSGID_OBJ_PTRN}"}
        match => { "message" => "%{SMG_MSG_SIZE_OBJ_PTRN}"}
        match => { "message" => "%{SMG_EHLO_OBJ_PTRN}"}
        match => { "message" => "%{SMG_LOGICAL_IP_OBJ_PTRN}"}
        
        # single to split
        match => { "message" => "%{SMG_ATTACH_OBJ_PTRN}"}
        match => { "message" => "%{SMG_ORCPTS_OBJ_PTRN}"}
        
        # objects
        match => { "message" => "%{SMG_UNTESTED_OBJ_PTRN}"}
        match => { "message" => "%{SMG_VERDICT_OBJ_PTRN}"}
        match => { "message" => "%{SMG_IRCPTACTION_OBJ_PTRN}"}
        match => { "message" => "%{SMG_TRACKERID_OBJ_PTRN}"}
        match => { "message" => "%{SMG_FIRED_OBJ_PTRN}"}
        match => { "message" => "%{SMG_DELIVER_OBJ_PTRN}"}
        
        # need to check!!!!
         match => { "message" => "%{SMG_DELIVERY_FAILURE_OBJ_PTRN}"}
         match => { "message" => "%{SMG_TRANS_FAILURE_OBJ_PTRN}"}

        
        #everything else to bin
        match => { "message" => "%{GREEDYDATA:_else}"}


        #add_field => [ "received_at", "%{@timestamp}" ]
        #add_field => [ "received_from", "%{host}" ]
          
    }
    
    date {
        match => [ "smgdate", "UNIX" ]
        target => [ "smgdate_formatted" ] 
    }
   
    mutate { 
        split => ["[attach][attachments]","|"]
        split => ["[untested][untested]","|"]      
        split => ["[orcpts][recipient]", "|"]    
        split => ["[ircptaction][rcpt_action]", "|"]
        split => ["[fired][fired]", "|"]
        add_field => { "indexname" => "logstash-smg2" }

    }   #
    

#   if[untested] {
#       ruby {
#           init => "require 'json'"
#           code => "
#               p 'ruby start'
#               file = File.read('lookup.json')
#               data = JSON.parse(file)
#               
#               untesteds = event.get('untested')
#               p 'event start'
#               p event
#               p 'event end'
#               p 'untesteds start'
#               p untesteds
#               p 'untesteds end'
#               untesteds['untested'].each { |un| 
#                   p 'kolejny'
#                   p un
#                   p 'data' 
#                   p data[un]
#                   (untesteds['untested_translated'] ||= []) << data[un]['desc']
#                   }
#               p 'ruby end'
#           "
#       }
#   }
 

   
   if [_else] {
	drop {}
#       mutate {replace => { "indexname" => "everything_else" }}
   }

}


output {
  stdout { codec => rubydebug }
  
  
    
    if [indexname] == "logstash-smg2" {
        elasticsearch {
            hosts => ["localhost:9200"]
            action => "update"
            doc_as_upsert => true
            sniffing => false
            retry_on_conflict => 20
            manage_template => true
            index => "%{indexname}"
            document_id => "%{smguid}"
            document_type => "smg_message"
            script => "
                if (event.accept) {ctx._source.accept = event.accept}
                if (event.tls_received) {ctx._source.tls_received = event.tls_received}
                if (event.subject) {ctx._source.subject = event.subject}
                if (event.source) {ctx._source.source = event.source}
                if (event.sender) {ctx._source.sender = event.sender}
                if (event.msgid) {ctx._source.msgid = event.msgid}
                if (event.msg_size) {ctx._source.msg_size = event.msg_size}
                if (event.ehlo) {ctx._source.ehlo = event.ehlo}
                if (event.logical_ip) {ctx._source.logical_ip = event.logical_ip}
                
                if (event.attach) {ctx._source.attach = event.attach}
                if (event.orcpts) {ctx._source.orcpts = event.orcpts}
                
                
                if (event.untested) {
                    if (ctx._source.untesteds) {
                        ctx._source.untesteds += event.untested
                    } else {
                        ctx._source.untesteds = [event.untested]
                    }
                }
                
                if (event.verdict) {
                    if (ctx._source.verdicts) {
                        ctx._source.verdicts += event.verdict
                    } else {
                        ctx._source.verdicts = [event.verdict]
                    }
                }
            
                if (event.ircptaction) {
                    if (ctx._source.ircptactions) {
                        ctx._source.ircptactions += event.ircptaction
                    } else {
                        ctx._source.ircptactions = [event.ircptaction]
                    }
                }
        
                if (event.trackerid) {
                    if (ctx._source.trackerids) {
                        ctx._source.trackerids += event.trackerid
                    } else {
                        ctx._source.trackerids = [event.trackerid]
                    }
                }
                
                if (event.fired) {
                    if (ctx._source.fireds) {
                        ctx._source.fireds += event.fired
                    } else {
                        ctx._source.fireds = [event.fired]
                    }
                }
                
                if (event.delivery_failure) {
                    if (ctx._source.delivery_failures) {
                        ctx._source.delivery_failures += event.delivery_failure
                    } else {
                        ctx._source.delivery_failures = [event.delivery_failure]
                    }
                }        
                
                if (event.trans_failure) {
                    if (ctx._source.trans_failures) {
                        ctx._source.trans_failures += event.trans_failure
                    } else {
                        ctx._source.trans_failures = [event.trans_failure]
                    }
                }    
                
                
                if (event.deliver) {
                    if (ctx._source.delivers) {
                        ctx._source.delivers += event.deliver
                    } else {
                        ctx._source.delivers = [event.deliver]
                    }
                }            
            
                if(ctx._source.raw_messages) {
                    ctx._source.raw_messages += event.message
                } else {
                    ctx._source.raw_messages = [event.message]
                }
        
            "
	    script_lang => "groovy"
        }
    } else {
        elasticsearch {
            hosts => ["localhost:9200"]
            sniffing => true
            manage_template => true
            index => "everything_else"
            document_type => "everything_else"
        }
    }
}

  #geoip {
   #     source => "[accept][accept_ip]"
   #     target => "[accept][accept_ip_geo]"
   #     database => "/etc/logstash/GeoLiteCity.dat"

    #}
    
   # if [accept][accept_ip] =~ /^192\.168\./ {
   #     mutate { replace      => { "[geoip][timezone]"      => "Europe/Poland" } }
   #     mutate { replace      => { "[geoip][country_name]"  => "Internal Addresses" } }
   #     mutate { replace      => { "[geoip][country_code2]" => "WPL" } }
   #     mutate { replace      => { "[geoip][country_code3]" => "WPL" } }
   #     mutate { remove_field => [ "[geoip][location]" ] }
   #     mutate { add_field    => { "[geoip][location]"      => "170.525" } }
   #     mutate { add_field    => { "[geoip][location]"      => "-45.865" } }
   #     mutate { convert      => [ "[geoip][location]",        "float" ] }
   #     mutate { replace      => [ "[geoip][latitude]",        -45.856 ] }
   #     mutate { convert      => [ "[geoip][latitude]",        "float" ] }
   #     mutate { replace      => [ "[geoip][longitude]",       170.525 ] }
   #     mutate { convert      => [ "[geoip][longitude]",       "float" ] }
   # }


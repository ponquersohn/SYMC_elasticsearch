
input {
    file { 
	path => "/var/log/smg.log"
	start_position => "beginning"
        discover_interval => "1"
    }
}

filter { 
    grok { 
        break_on_match => "true"
        patterns_dir => ["/etc/logstash/conf.d/smg/smg_patterns"]
        # single lines
        match => { "message" => "%{SMG_ACCEPT_OBJ_PTRN}"}
        match => { "message" => "%{SMG_EHLO_OBJ_PTRN}"}
        match => { "message" => "%{SMG_TLS_RECEIVED_OBJ_PTRN}"}
        match => { "message" => "%{SMG_SUBJECT_OBJ_PTRN}"}
        match => { "message" => "%{SMG_SOURCE_OBJ_PTRN}"}
        match => { "message" => "%{SMG_SENDER_OBJ_PTRN}"}
        match => { "message" => "%{SMG_MSGID_OBJ_PTRN}"}
        match => { "message" => "%{SMG_MSG_SIZE_OBJ_PTRN}"}
        match => { "message" => "%{SMG_LOGICAL_IP_OBJ_PTRN}"}

        
        
#        match => { "message" => "%{SMG_TD_RESULT_PTRN}"}
#        match => { "message" => "%{SMG_RECEIVED_PTRN}"}
#        match => { "message" => "%{SMG_RESUBMIT_PTRN}"}
#        match => { "message" => "%{SMG_UNSCANNABLE_PTRN}"}
#        match => { "message" => "%{SMG_VIRUS_PTRN}"}


         # single to split
        match => { "message" => "%{SMG_ATTACH_OBJ_PTRN}"}
        match => { "message" => "%{SMG_ORCPTS_OBJ_PTRN}"}
     
        
        # objects
        match => { "message" => "%{SMG_UNTESTED_OBJ_PTRN}"}
        
        
        
#        match => { "message" => "%{SMG_VERDICT_PTRN}"}
#        match => { "message" => "%{SMG_IRCPTACTION_PTRN}"}
#        match => { "message" => "%{SMG_TRACKERID_PTRN}"}
#        match => { "message" => "%{SMG_FIRED_PTRN}"}
#        match => { "message" => "%{SMG_DELIVER_PTRN}"}
#        
#        # need to check!!!!
#        match => { "message" => "%{SMG_DELIVERY_FAILURE_PTRN}"}
#        match => { "message" => "%{SMG_TRANS_FAILURE_PTRN}"}
#
#        #everything else to bin
#
#        match => { "message" => "%{SMG_ELSE}"}
#
#
#        #add_field => [ "received_at", "%{@timestamp}" ]
#        #add_field => [ "received_from", "%{host}" ]
          
    }
    
    date {
        match => [ "[accept][date]", "UNIX" ]
        target => [ "[accept][date_formatted]" ] 
    }
    
    date {
        match => [ "[ehlo][date]", "UNIX" ]
        target => [ "[ehlo][date_formatted]" ] 
    }

    date {
        match => [ "[tls_received][date]", "UNIX" ]
        target => [ "[tls_received][date_formatted]" ] 
    }

    date {
        match => [ "[subject][date]", "UNIX" ]
        target => [ "[subject][date_formatted]" ] 
    }    

    date {
        match => [ "[source][date]", "UNIX" ]
        target => [ "[source][date_formatted]" ] 
    }    
    date {
        match => [ "[sender][date]", "UNIX" ]
        target => [ "[sender][date_formatted]" ] 
    }    
    date {
        match => [ "[msgid][date]", "UNIX" ]
        target => [ "[msgid][date_formatted]" ] 
    }    
    date {
        match => [ "[msg_size][date]", "UNIX" ]
        target => [ "[msg_size][date_formatted]" ] 
    }    
    date {
        match => [ "[logical_ip][date]", "UNIX" ]
        target => [ "[logical_ip][date_formatted]" ] 
    }        

    date {
        match => [ "[attach][date]", "UNIX" ]
        target => [ "[attach][date_formatted]" ] 
    }        
    date {
        match => [ "[orcpts][date]", "UNIX" ]
        target => [ "[orcpts][date_formatted]" ] 
    }        
    date {
        match => [ "[untested][date]", "UNIX" ]
        target => [ "[untested][date_formatted]" ] 
    }            

	mutate { 
		split => ["[attach][attachments]","|"]
		split => ["[orcpts][recipients]", "|"]  
        split => ["[untested][untested]","|"]      
  
#		split => ["[ircptaction]", "|"]
#		split => ["[fired]", "|"]
	}   

 	if [action]=="LOGICAL_IP"  {
 		geoip {
 			source=> "[logical_ip][logical_ip]"
 			target=> "[logical_ip][logical_ip_geoip]"
 		} 
 	   	if [logical_ip][logical_ip] =~ /^10\./ {
 			mutate { replace      => { "[logical_ip][logical_ip_geoip][timezone]"      => "Europe/Poland" } }
 			mutate { replace      => { "[logical_ip][logical_ip_geoip][country_name]"  => "Internal Addresses" } }
 			mutate { replace      => { "[logical_ip][logical_ip_geoip][country_code2]" => "WPL" } }
 			mutate { replace      => { "[logical_ip][logical_ip_geoip][country_code3]" => "WPL" } }
 			mutate { remove_field => [ "[logical_ip][logical_ip_geoip][location]" ] }
 			mutate { add_field    => { "[logical_ip][logical_ip_geoip][location]"      => "170.525" } }
 			mutate { add_field    => { "[logical_ip][logical_ip_geoip][location]"      => "-45.865" } }
 			mutate { convert      => [ "[logical_ip][logical_ip_geoip][location]",        "float" ] }
 			mutate { replace      => [ "[logical_ip][logical_ip_geoip][latitude]",        -45.856 ] }
 			mutate { convert      => [ "[logical_ip][logical_ip_geoip][latitude]",        "float" ] }
 			mutate { replace      => [ "[logical_ip][logical_ip_geoip][longitude]",       170.525 ] }
 			mutate { convert      => [ "[logical_ip][logical_ip_geoip][longitude]",       "float" ] }
 		}
 	}
 
#        if [action]=="DELIVER"  {
#                geoip { 
#                        source=> "delivery_ip"
#                        target=> "delivery_ip_geoip"
#                }
#                if [delivery_ip] =~ /^10\./ {
#                        mutate { replace      => { "[delivery_ip_geoip][timezone]"      => "Europe/Poland" } }
#                        mutate { replace      => { "[delivery_ip_geoip][country_name]"  => "Internal Addresses" } }
#                        mutate { replace      => { "[delivery_ip_geoip][country_code2]" => "WPL" } }
#                        mutate { replace      => { "[delivery_ip_geoip][country_code3]" => "WPL" } }
#                        mutate { remove_field => [ "[delivery_ip_geoip][location]" ] }
#                        mutate { add_field    => { "[delivery_ip_geoip][location]"      => "170.525" } }
#                        mutate { add_field    => { "[delivery_ip_geoip][location]"      => "-45.865" } }
#                        mutate { convert      => [ "[delivery_ip_geoip][location]",        "float" ] }
#                        mutate { replace      => [ "[delivery_ip_geoip][latitude]",        -45.856 ] }
#                        mutate { convert      => [ "[delivery_ip_geoip][latitude]",        "float" ] }
#                        mutate { replace      => [ "[delivery_ip_geoip][longitude]",       170.525 ] }
#                        mutate { convert      => [ "[delivery_ip_geoip][longitude]",       "float" ] }
#                }
#        }
#
#        if [action]=="ACCEPT"  {
#                geoip {
#                        source=> "accept_ip"
#                        target=> "accept_ip_geoip"
#                }
#                if [accept_ip] =~ /^10\./ {
#                        mutate { replace      => { "[accept_ip_geoip][timezone]"      => "Europe/Poland" } }
#                        mutate { replace      => { "[accept_ip_geoip][country_name]"  => "Internal Addresses" } }
#                        mutate { replace      => { "[accept_ip_geoip][country_code2]" => "WPL" } }
#                        mutate { replace      => { "[accept_ip_geoip][country_code3]" => "WPL" } }
#                        mutate { remove_field => [ "[accept_ip_geoip][location]" ] }
#                        mutate { add_field    => { "[accept_ip_geoip][location]"      => "170.525" } }
#                        mutate { add_field    => { "[accept_ip_geoip][location]"      => "-45.865" } }
#                        mutate { convert      => [ "[accept_ip_geoip][location]",        "float" ] }
#                        mutate { replace      => [ "[accept_ip_geoip][latitude]",        -45.856 ] }
#                        mutate { convert      => [ "[accept_ip_geoip][latitude]",        "float" ] }
#                        mutate { replace      => [ "[accept_ip_geoip][longitude]",       170.525 ] }
#                        mutate { convert      => [ "[accept_ip_geoip][longitude]",       "float" ] }
#                }
#        }
    
   if [_else] {
     	drop {}
        mutate {add_field => { "action" => "PARSE_ERROR" }}
   } 
	
   mutate {
		add_field => { "[@metadata][action]" => "%{action}" }
  }
   mutate { 
		lowercase => [ "[@metadata][action]" ]
  }

}


output {
	stdout { codec => rubydebug }
	elasticsearch {
		hosts => ["localhost:9200"]
		#index => "smg-%{[@metadata][action]}-%{+YYYY.MM.dd}"
		index => "smg-objects-%{+YYYY.MM.dd}"
        document_id => "%{smguid}"
        action => "update"
        doc_as_upsert => true
        retry_on_conflict => 100

        script_lang => "painless"
        script_type => "inline"
        script_var_name => "event"
        script => '
            #if (params.event.containsKey("accept")) {ctx._source.accept = params.event.accept;}
            #if (params.event.containsKey("ehlo")) {ctx._source.ehlo = params.event.ehlo;}
            #if (params.event.containsKey("tls_received")) {ctx._source.tls_received = params.event.tls_received;}
            #if (params.event.containsKey("subject")) {ctx._source.subject = params.event.subject;}
            #if (params.event.containsKey("source")) {ctx._source.source = params.event.source;}
            #if (params.event.containsKey("sender")) {ctx._source.sender = params.event.sender;}
            #if (params.event.containsKey("msgid")) {ctx._source.msgid = params.event.msgid;}
            #if (params.event.containsKey("msg_size")) {ctx._source.msg_size = params.event.msg_size;}
            #if (params.event.containsKey("logical_ip")) {ctx._source.logical_ip = params.event.logical_ip;}
          
            
            #if (params.event.containsKey("untested")) {
                ctx._source.put("untest", new ArrayList());
                ctx._source.untest.add(params.event.untested);
                ctx._source.remove("untested");
            #}
   
            '
          
	}
}
 

